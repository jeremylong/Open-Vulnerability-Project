/*
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) 2023 Jeremy Long. All Rights Reserved.
 */
package io.github.jeremylong.vulntools;

import io.github.jeremylong.vulntools.client.RecordDataSource;
import io.github.jeremylong.vulntools.client.ghsa.GitHubSecurityAdvisoryClient;
import io.github.jeremylong.vulntools.client.ghsa.GitHubSecurityAdvisoryClientBuilder;
import io.github.jeremylong.vulntools.client.ghsa.SecurityAdvisory;
import io.github.jeremylong.vulntools.client.nvd.DefCveItem;
import io.github.jeremylong.vulntools.client.nvd.NvdApiException;
import io.github.jeremylong.vulntools.client.nvd.NvdCveApi;
import io.github.jeremylong.vulntools.client.nvd.NvdCveApiBuilder;
import io.github.jeremylong.vulntools.database.VulnerabilityDatabase;
import io.github.jeremylong.vulntools.database.model.Property;
import io.github.jeremylong.vulntools.database.model.osv.modified.Vulnerability;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

public class VulnerabilityService {

    public static final String NVD_LAST_UPDATED = "nvd_last_updated";
    public static final String GHSA_LAST_UPDATED = "ghsa_last_updated";

    private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityService.class);

    public void updateDatabase(String ghsaToken) {
        updateDatabase(ghsaToken, null);
    }

    public void updateDatabase(String ghsaToken, String nvdApiToken) {
        try (VulnerabilityDatabase database = new VulnerabilityDatabase()) {
            LOG.info("Starting GHSA----------------------");
            LOG.info("-----------------------------------");
            loadGHSA(ghsaToken, database);
            LOG.info("Starting NVD-----------------------");
            LOG.info("-----------------------------------");
            LOG.info("-----------------------------------");
            LOG.info("-----------------------------------");
            LOG.info("-----------------------------------");
            loadNVD(nvdApiToken, database);
            LOG.info("-----------------------------------");
            LOG.info("-----------------------------------");
            LOG.info("-----------------------------------");
            LOG.info("Ending Update----------------------");
        } catch (Exception e) {
            LOG.error("failed... sadness...");
            e.printStackTrace();
        }
    }

    private void loadNVD(String apiKey, VulnerabilityDatabase database) throws Exception {
        NvdCveApiBuilder builder = NvdCveApiBuilder.aNvdCveApi();
        if (apiKey != null) {
            if (apiKey.startsWith("op:")) {
                throw new Exception("Invalid NVD API token - received a 1password token");
            } else {
                builder.withApiKey(apiKey);
            }
        }

        Property lastUpdated = database.getProperty(NVD_LAST_UPDATED);
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("uuuu-MM-dd'T'HH:mm:ssX");
        if (lastUpdated != null) {
            ZonedDateTime start = ZonedDateTime.parse(lastUpdated.getValue(), dtf);
            ZonedDateTime end = start.minusDays(-120);
            builder.withLastModifiedFilter(start, end);
        } else {
            lastUpdated = new Property();
            lastUpdated.setKey(NVD_LAST_UPDATED);
        }

        try (NvdCveApi api = builder.build(); RecordDataSource<DefCveItem> client = new RecordDataSource<>(api)) {
            while (client.hasNext()) {
                try {
                    DefCveItem entry = client.next();
                    if (entry != null) {
                        List<Vulnerability> existingVulnerabilities = database.getVulnerability(entry.getCve().getId());
                        boolean addEntry = true;
                        if (existingVulnerabilities != null && !existingVulnerabilities.isEmpty()) {
                            // TODO - add the CPE to the existing GHSA vulnerabilities - to propagate vulnerability
                            // matches
                            for (Vulnerability v : existingVulnerabilities) {
                                // if the vulnerability is only from the NVD delete it
                                if (v.getIdentifiers().size() == 1) {
                                    database.delete(v);
                                } else {
                                    // already covered by GH Security Advisories
                                    addEntry = false;
                                }
                            }
                        }
                        if (addEntry) {
                            Vulnerability newVuln = VulnerabilityTransformer.from(entry);
                            if (newVuln != null) {
                                LOG.info("adding: {}", entry.getCve().getId());
                                database.store(newVuln);
                            }
                        }
                    }
                } catch (NvdApiException ex) {
                    LOG.error("Error retrieving the NVD data", ex);
                }
            }
            database.commit();
            if (client.getLastUpdated() != null) {
                lastUpdated.setValue(client.getLastUpdated().format(dtf));
                database.store(lastUpdated);
                database.commit();
            }
        }
    }

    private void loadGHSA(String apiKey, VulnerabilityDatabase database) throws Exception {
        if (apiKey == null || apiKey.isBlank() || apiKey.startsWith("op:")) {
            throw new Exception("Invalid github API token - please set a valid environment variable GITHUB_TOKEM");
        }
        GitHubSecurityAdvisoryClientBuilder builder = GitHubSecurityAdvisoryClientBuilder
                .aGitHubSecurityAdvisoryClient().withApiKey(apiKey);

        Property lastUpdated = database.getProperty(GHSA_LAST_UPDATED);
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("uuuu-MM-dd'T'HH:mm:ssX");
        if (lastUpdated != null) {
            ZonedDateTime date = ZonedDateTime.parse(lastUpdated.getValue(), dtf);
            builder.withUpdatedSinceFilter(date);
        } else {
            lastUpdated = new Property();
            lastUpdated.setKey(GHSA_LAST_UPDATED);
        }

        try (GitHubSecurityAdvisoryClient api = builder.build();
                RecordDataSource<SecurityAdvisory> client = new RecordDataSource<>(api)) {

            while (client.hasNext()) {
                SecurityAdvisory entry = client.next();
                if (entry != null) {
                    // TODO - also search for CVEs on the advisory (or other datasources once added) - if we have one
                    // from
                    // GHSA we trust it more
                    List<Vulnerability> existingVulnerabilities = database.getVulnerability(entry.getGhsaId());
                    // updating is hard... as removing a signle version or affected entry in a list of entries is
                    // difficult
                    // once data is coming from multiple data sources. We treat GHSA as the most accurate.
                    if (existingVulnerabilities != null && !existingVulnerabilities.isEmpty()) {
                        for (Vulnerability v : existingVulnerabilities) {
                            database.delete(v);
                        }
                    }
                    Vulnerability newVuln = VulnerabilityTransformer.from(entry);
                    database.store(newVuln);
                }
            }
            if (client.getLastUpdated() != null) {
                lastUpdated.setValue(client.getLastUpdated().format(dtf));
                database.store(lastUpdated);
            }
        }
        database.commit();
    }

}
