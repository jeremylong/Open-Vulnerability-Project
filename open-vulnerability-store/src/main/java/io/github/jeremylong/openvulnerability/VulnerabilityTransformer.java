/*
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) 2023 Jeremy Long. All Rights Reserved.
 */
package io.github.jeremylong.openvulnerability;

import io.github.jeremylong.openvulnerability.client.ghsa.CVSS;
import io.github.jeremylong.openvulnerability.client.ghsa.Identifier;
import io.github.jeremylong.openvulnerability.client.ghsa.SecurityAdvisory;
import io.github.jeremylong.openvulnerability.client.nvd.Config;
import io.github.jeremylong.openvulnerability.client.nvd.CpeMatch;
import io.github.jeremylong.openvulnerability.client.nvd.CveItem;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV2;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV30;
import io.github.jeremylong.openvulnerability.client.nvd.CvssV31;
import io.github.jeremylong.openvulnerability.client.nvd.DefCveItem;
import io.github.jeremylong.openvulnerability.client.nvd.LangString;
import io.github.jeremylong.openvulnerability.client.nvd.Metrics;
import io.github.jeremylong.openvulnerability.client.nvd.Node;
import io.github.jeremylong.openvulnerability.client.nvd.Weakness;
import io.github.jeremylong.openvulnerability.model.Affected;
import io.github.jeremylong.openvulnerability.model.CWE;
import io.github.jeremylong.openvulnerability.model.Range;
import io.github.jeremylong.openvulnerability.model.Reference;
import io.github.jeremylong.openvulnerability.model.Severity;
import io.github.jeremylong.openvulnerability.model.Source;
import io.github.jeremylong.openvulnerability.model.VersionRange;
import io.github.jeremylong.openvulnerability.model.Vulnerability;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import us.springett.parsers.cpe.Cpe;
import us.springett.parsers.cpe.CpeBuilder;
import us.springett.parsers.cpe.CpeParser;
import us.springett.parsers.cpe.exceptions.CpeParsingException;
import us.springett.parsers.cpe.exceptions.CpeValidationException;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.stream.Collectors;

public final class VulnerabilityTransformer {

    private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityTransformer.class);

    private VulnerabilityTransformer() {
    }

    public static Vulnerability from(SecurityAdvisory advisory) {
        Vulnerability v = new Vulnerability();
        for (Identifier id : advisory.getIdentifiers()) {
            v.addIdentifier(id.getValue());
        }
        v.setPublished(advisory.getPublishedAt());
        v.setModified(advisory.getUpdatedAt());
        v.setSummary(advisory.getSummary());
        v.setDetails(advisory.getDescription());

        Source source = new Source();
        source.setName("ghsa");
        v.addSource(source);
        if (advisory.getWithdrawnAt() != null) {
            source.setWithdrawn(advisory.getWithdrawnAt());
            v.setWithdrawn(advisory.getWithdrawnAt());
        }
        v.addSeverity(convert(advisory.getSeverity(), advisory.getCvss()));

        if (advisory.getVulnerabilities() != null) {
            Affected affected = null;
            for (io.github.jeremylong.openvulnerability.client.ghsa.Vulnerability ghv : advisory.getVulnerabilities()
                    .getEdges()) {
                final String ecosystem = ghv.getPackage().getEcosystem();
                final String name = ghv.getPackage().getName();
                if (affected == null || !ecosystem.equals(affected.getEcosystem())
                        || !name.equals(affected.getName())) {
                    if (affected != null) {
                        v.addAffected(affected);
                    }
                    affected = new Affected();

                    affected.setEcosystem(ecosystem);
                    affected.setName(name);
                    final String purl = determinePurl(ecosystem, name);
                    if (purl != null) {
                        affected.setPurl(purl);
                    }
                    if (ghv.getSeverity() != null) {
                        affected.addSeverity(convert(ghv.getSeverity(), advisory.getCvss()));
                    }
                }
                Range range = new Range();
                VersionRange versions = new VersionRange();
                String[] ranges = ghv.getVulnerableVersionRange().split(",");
                if (ranges.length == 1) {
                    if (ranges[0].trim().startsWith("<")) {
                        versions.setEnd(ranges[0].trim());
                    } else {
                        versions.setBegin(ranges[0].trim());
                    }
                } else {
                    versions.setBegin(ranges[0].trim());
                    versions.setEnd(ranges[1].trim());
                }
                range.addVersionRange(versions);
                affected.addRange(range);
            }
            if (affected != null) {
                v.addAffected(affected);
            }
        }
        if (advisory.getCwes() != null && advisory.getCwes().getEdges() != null) {
            for (io.github.jeremylong.openvulnerability.client.ghsa.CWE advCwe : advisory.getCwes().getEdges()) {
                CWE cwe = new CWE();
                cwe.setCweId(advCwe.getCweId());
                cwe.setDescription(advCwe.getDescription());
                cwe.setName(advCwe.getName());
                v.addCwe(cwe);
            }
        }
        if (advisory.getReferences() != null) {
            for (io.github.jeremylong.openvulnerability.client.ghsa.Reference advRef : advisory.getReferences()) {
                Reference ref = new Reference();
                if (advRef.getUrl().contains("github.com/advisories/")
                        || advRef.getUrl().contains("nvd.nist.gov/vuln/detail/")) {
                    ref.setType("ADVISORY");
                } else {
                    ref.setType("WEB");
                }
                ref.setUrl(advRef.getUrl());
                v.addReference(ref);
            }
        }
        return v;
    }

    private static String determinePurl(String ecosystem, String name) {
        // TODO complete implementation
        switch (ecosystem.toUpperCase()) {
            // TODO use a purl library so we get the encoding correct as we should have %40angular instead of @angular
            case "MAVEN":
                return "pkg:maven/" + name.replace(":", "/");
            case "GO":
                return "pkg:golang/" + name;
            case "NPM":
                return "pkg:npm/" + name;
            case "RUST":
                return "pkg:rust/" + name;
            case "NUGET":
                return "pkg:nuget/" + name;
            case "COMPOSER":
            case "PIP":
                return "pkg:pypi/" + name;
            case "RUBYGEMS":
                return "pkg:gem/" + name;
            case "PUB":
                // dart
                return "pkg:pub/" + name;
            case "ERLANG":
                return "pkg:hex/" + name;
        }
        return null;
    }

    private static Severity convert(io.github.jeremylong.openvulnerability.client.ghsa.Severity severity, CVSS cvss) {
        Severity sev = new Severity();
        sev.setSource("ghsa");
        sev.setSeverity(severity.value());
        if (cvss != null && cvss.getVectorString() != null && cvss.getVectorString().isBlank()) {
            sev.setNumericScore(cvss.getScore());
            sev.setScore(cvss.getVectorString());
            if (cvss.getVectorString().startsWith("CVSS:")) {
                final int slash = cvss.getVectorString().indexOf("/");
                String version = cvss.getVectorString().substring(5, slash - 1);
                if (version.endsWith(".0")) {
                    version = version.substring(0, version.length() - 2);
                }
                version = version.replace('.', '_');
                sev.setType("CVSS_V" + version);
            } else if (cvss.getVectorString().startsWith("AV")) {
                sev.setType("CVSS_V2");
            }
        }
        return sev;
    }

    public static Vulnerability from(DefCveItem entry) {
        CveItem cve = entry.getCve();

        Vulnerability v = new Vulnerability();
        v.addIdentifier(cve.getId());
        v.setPublished(cve.getPublished());
        v.setModified(cve.getLastModified());
        String desc = extractEnglishDescription(cve);
        v.setSummary("Status: " + cve.getVulnStatus() + ". " + desc);
        v.setDetails(desc);

        Source source = new Source();
        source.setName("nvd");
        v.addSource(source);

        if ("Rejected".equalsIgnoreCase(cve.getVulnStatus())) {
            source.setWithdrawn(cve.getLastModified());
            v.setWithdrawn(cve.getLastModified());
        }

        v.addSeverity(convert(cve.getMetrics()));
        if (cve.getConfigurations() != null) {
            Affected affected = null;
            Range range = null;
            final List<CpeMatch> matches = collectMatches(cve);
            for (CpeMatch match : matches) {
                Cpe cpe;
                try {
                    cpe = CpeParser.parse(match.getCriteria());
                } catch (CpeParsingException e) {
                    LOG.debug("error parsing CPE, skipping entry " + match.getCriteria(), e);
                    continue;
                }

                String affectedCPE;
                CpeBuilder cpeBuilder = new CpeBuilder();
                try {
                    affectedCPE = cpeBuilder.part(cpe.getPart()).wfVendor(cpe.getWellFormedVendor())
                            .wfProduct(cpe.getWellFormedProduct()).build().toCpe23FS();
                } catch (CpeValidationException e) {
                    LOG.debug("error building CPE, skipping entry " + match.getCriteria(), e);
                    continue;
                }

                if (affected == null || !affected.getCpe().equals(affectedCPE)) {
                    affected = new Affected();
                    affected.setCpe(affectedCPE);
                    range = new Range();
                    affected.addRange(range);

                    v.addAffected(affected);
                }

                VersionRange versions = new VersionRange();

                if (hasValue(match.getVersionEndExcluding())) {
                    versions.setEnd("< " + match.getVersionEndExcluding());
                } else if (hasValue(match.getVersionEndIncluding())) {
                    versions.setEnd("<= " + match.getVersionEndIncluding());
                }

                if (hasValue(match.getVersionStartExcluding())) {
                    versions.setBegin("> " + match.getVersionStartExcluding());
                } else if (hasValue(match.getVersionStartIncluding())) {
                    versions.setBegin(">= " + match.getVersionStartIncluding());
                } else if ("*".equals(cpe.getVersion()) || "-".equals(cpe.getVersion())) {
                    versions.setBegin("*");
                } else {
                    versions.setBegin("= " + cpe.getVersion());
                }
                range.addVersionRange(versions);
            }
        }

        if (cve.getWeaknesses() != null) {
            for (Weakness weakness : cve.getWeaknesses()) {
                for (String value : extractEnglishCWE(weakness)) {
                    CWE cwe = new CWE();
                    cwe.setCweId(value);
                    v.addCwe(cwe);
                }
            }
        }
        if (cve.getReferences() != null) {
            for (io.github.jeremylong.openvulnerability.client.nvd.Reference reference : cve.getReferences()) {
                if (hasValue(reference.getUrl())) {
                    Reference ref = new Reference();
                    ref.setUrl(reference.getUrl());
                    if (reference.getUrl().contains("github.com/advisories/")
                            || reference.getUrl().contains("nvd.nist.gov/vuln/detail/")) {
                        ref.setType("ADVISORY");
                    } else {
                        ref.setType("WEB");
                    }
                    v.addReference(ref);
                }
            }
        }
        return v;
    }

    private static boolean hasValue(String str) {
        return str != null && !str.isBlank();
    }

    private static List<CpeMatch> collectMatches(CveItem cve) {
        List<CpeMatch> matches = new ArrayList<>();
        for (Config config : cve.getConfigurations()) {
            if (config.getNegate() == null || !config.getNegate()) {
                for (Node node : config.getNodes()) {
                    if (node.getNegate() == null || !node.getNegate()) {
                        matches.addAll(node.getCpeMatch());
                    }
                }
            }
        }
        if (matches.isEmpty()) {
            return matches;
        }
        return matches.stream().filter(m -> m.getVulnerable() == null || m.getVulnerable())
                .sorted(Comparator.comparing(n -> n.getCriteria())).collect(Collectors.toList());
    }

    private static Severity convert(Metrics metrics) {
        Severity sev = new Severity();
        if (metrics.getCvssMetricV31() != null && !metrics.getCvssMetricV31().isEmpty()) {
            CvssV31 cvss = metrics.getCvssMetricV31().get(0);
            sev.setType("CVSS_V3.1");
            sev.setNumericScore(cvss.getCvssData().getBaseScore());
            sev.setScore(cvss.getCvssData().getVectorString());
            sev.setSeverity(cvss.getCvssData().getBaseSeverity().value());
            if (cvss.getSource() != null) {
                sev.setSource(cvss.getSource());
            } else {
                sev.setSource("nvd");
            }
        } else if (metrics.getCvssMetricV30() != null && !metrics.getCvssMetricV30().isEmpty()) {
            CvssV30 cvss = metrics.getCvssMetricV30().get(0);
            sev.setType("CVSS_V3");
            sev.setNumericScore(cvss.getCvssData().getBaseScore());
            sev.setScore(cvss.getCvssData().getVectorString());
            sev.setSeverity(cvss.getCvssData().getBaseSeverity().value());
            if (cvss.getSource() != null) {
                sev.setSource(cvss.getSource());
            } else {
                sev.setSource("nvd");
            }
        } else if (metrics.getCvssMetricV2() != null && !metrics.getCvssMetricV2().isEmpty()) {
            CvssV2 cvss = metrics.getCvssMetricV2().get(0);
            sev.setType("CVSS_V2");
            sev.setNumericScore(cvss.getCvssData().getBaseScore());
            sev.setScore(cvss.getCvssData().getVectorString());
            sev.setSeverity(cvss.getCvssData().getBaseSeverity());
            if (cvss.getSource() != null) {
                sev.setSource(cvss.getSource());
            } else {
                sev.setSource("nvd");
            }
        }
        return sev;
    }

    private static List<String> extractEnglishCWE(Weakness weakness) {
        return weakness.getDescription().stream().filter(ls -> "en".equals(ls.getLang())).map(LangString::getValue)
                .filter(v -> v.startsWith("CWE")).collect(Collectors.toList());
    }

    private static String extractEnglishDescription(CveItem cve) {
        return cve.getDescriptions().stream().filter(ls -> "en".equals(ls.getLang())).map(LangString::getValue)
                .collect(Collectors.joining(" "));
    }
}
