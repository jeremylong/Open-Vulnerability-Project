/*
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) 2023 Jeremy Long. All Rights Reserved.
 */
package io.github.jeremylong.openvulnerability;

import io.github.jeremylong.openvulnerability.model.Property;
import io.github.jeremylong.openvulnerability.model.Vulnerability;
import jakarta.persistence.EntityManager;
import jakarta.persistence.EntityManagerFactory;
import jakarta.persistence.LockModeType;
import jakarta.persistence.Persistence;
import jakarta.persistence.TypedQuery;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.File;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class VulnerabilityDatabase implements AutoCloseable {
    private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityService.class);

    private final static String VULNERABILITY_BY_ID = "SELECT V FROM Vulnerability V INNER JOIN V.identifiers I WHERE I = :identifier";

    private long transactionCount = 0;
    private EntityManager session;

    private TypedQuery<Vulnerability> queryVulnerabilityById;

    public VulnerabilityDatabase() {
        this(new HashMap<String, String>());
    }

    public VulnerabilityDatabase(Map<String, String> persistenceMap) {
        ensureDataDirectory(persistenceMap);

        EntityManagerFactory emf = Persistence.createEntityManagerFactory("open-vunerability-data", persistenceMap);

        session = emf.createEntityManager();

        // Initialize Session Object
        // session = sessionFactory.openSession();
        // session.beginTransaction();
        session.getTransaction().begin();
        queryVulnerabilityById = session.createQuery(VULNERABILITY_BY_ID, Vulnerability.class);
    }

    private void ensureDataDirectory(Map<String, String> persistenceMap) {
        try {
            if (persistenceMap.containsKey("javax.persistence.jdbc.url")) {
                String path = persistenceMap.get("javax.persistence.jdbc.url");
                path = path.substring(path.indexOf(":", 5) + 1);
                File file = new File(path);
                if (!file.getParentFile().isDirectory() && !file.getParentFile().mkdirs()) {
                    LOG.debug("Unable to create data directory {}", file.getParentFile());
                }
            } else {
                Files.createDirectories(Paths.get("./data"));
            }
        } catch (IOException e) {
            // ignore for now
        }
    }

    public void store(Vulnerability vulnerability) {
        session.persist(vulnerability);
        batchCheckPoint();
    }

    public List<Vulnerability> getVulnerability(String identifier) {
        queryVulnerabilityById.setParameter("identifier", identifier);
        return queryVulnerabilityById.getResultList();
    }

    public void delete(Vulnerability v) {
        session.remove(v);
        batchCheckPoint();
    }

    private void batchCheckPoint() {
        transactionCount += 1;
        if (transactionCount % 1000 == 0) {
            session.flush();
            session.clear();
            transactionCount = 0;
        }
    }

    public void store(Property property) {
        session.persist(property);
    }

    public Property getProperty(String key) {
        return session.find(Property.class, key, LockModeType.NONE);
    }

    public void commit() {
        session.flush();
        session.clear();
    }

    @Override
    public void close() throws Exception {
        session.flush();
        session.clear();
        session.getTransaction().commit();
        session.close();
    }
}
