/*
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) 2023-2024 Jeremy Long. All Rights Reserved.
 */
package io.github.jeremylong.openvulnerability;

import edu.umd.cs.findbugs.annotations.SuppressFBWarnings;
import io.github.jeremylong.openvulnerability.client.RecordDataSource;
import io.github.jeremylong.openvulnerability.client.epss.EpssDataFeed;
import io.github.jeremylong.openvulnerability.client.epss.EpssItem;
import io.github.jeremylong.openvulnerability.client.ghsa.GitHubSecurityAdvisoryClient;
import io.github.jeremylong.openvulnerability.client.ghsa.GitHubSecurityAdvisoryClientBuilder;
import io.github.jeremylong.openvulnerability.client.ghsa.SecurityAdvisory;
import io.github.jeremylong.openvulnerability.client.kev.KevCatalog;
import io.github.jeremylong.openvulnerability.client.kev.KevDataFeed;
import io.github.jeremylong.openvulnerability.client.kev.KevItem;
import io.github.jeremylong.openvulnerability.client.nvd.DefCveItem;
import io.github.jeremylong.openvulnerability.client.nvd.NvdApiException;
import io.github.jeremylong.openvulnerability.client.nvd.NvdCveClient;
import io.github.jeremylong.openvulnerability.client.nvd.NvdCveClientBuilder;
import io.github.jeremylong.openvulnerability.model.Affected;
import io.github.jeremylong.openvulnerability.model.EpssScore;
import io.github.jeremylong.openvulnerability.model.KevEntry;
import io.github.jeremylong.openvulnerability.model.Property;
import io.github.jeremylong.openvulnerability.model.Vulnerability;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import us.springett.parsers.cpe.Cpe;
import us.springett.parsers.cpe.CpeParser;

import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import static io.github.jeremylong.openvulnerability.Configuration.KEY.GHSA_ENDPOINT;
import static io.github.jeremylong.openvulnerability.Configuration.KEY.GHSA_TOKEN;
import static io.github.jeremylong.openvulnerability.Configuration.KEY.NVD_API_KEY;
import static io.github.jeremylong.openvulnerability.Configuration.KEY.NVD_CPE_FILTER;
import static io.github.jeremylong.openvulnerability.Configuration.KEY.NVD_ENDPOINT;
import static io.github.jeremylong.openvulnerability.Configuration.KEY.PROCESS_EPSS;
import static io.github.jeremylong.openvulnerability.Configuration.KEY.PROCESS_GHSA;
import static io.github.jeremylong.openvulnerability.Configuration.KEY.PROCESS_KEV;
import static io.github.jeremylong.openvulnerability.Configuration.KEY.PROCESS_NVD;

public class VulnerabilityService {

    public static final String NVD_LAST_UPDATED = "nvd_last_updated";
    public static final String GHSA_LAST_UPDATED = "ghsa_last_updated";
    public static final String EPSS_LAST_UPDATED = "epss_last_updated";
    public static final String KEV_LAST_UPDATED = "kev_last_updated";

    private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityService.class);

    private Configuration configuration;

    @SuppressFBWarnings(value = {"EI_EXPOSE_REP",
            "EI_EXPOSE_REP2"}, justification = "I prefer to suppress these FindBugs warnings")
    public VulnerabilityService(Configuration configuration) {
        this.configuration = configuration;
    }

    public void updateDatabase() {
        Map<String, String> dbConfig = new HashMap<>();
        if (configuration.containsKey(Configuration.KEY.CONNECTION_STRING)) {
            dbConfig.put("hibernate.connection.url", configuration.get(Configuration.KEY.CONNECTION_STRING));
        }
        try (VulnerabilityDatabase database = new VulnerabilityDatabase(dbConfig)) {
            LOG.info("Begin Vulnerability Database Update");
            if (configuration.should(PROCESS_EPSS)) {
                LOG.info("Starting EPSS");
                loadEPSS(database);
                LOG.info("EPSS Complete");
            }
            if (configuration.should(PROCESS_KEV)) {
                LOG.info("Starting KEV");
                loadKev(database);
                LOG.info("KEV Complete");
            }
            if (configuration.should(PROCESS_GHSA)) {
                LOG.info("Starting GHSA");
                loadGHSA(database);
                LOG.info("GHSA Complete");
            }
            if (configuration.should(PROCESS_NVD)) {
                LOG.info("Starting NVD");
                loadNVD(database);
                LOG.info("NVD Complete");
            }

            LOG.info("Update Complete");
        } catch (Exception e) {
            LOG.error("Update Failed", e);
        }
    }

    private void loadKev(VulnerabilityDatabase database) {
        Property lastUpdated = database.getProperty(KEV_LAST_UPDATED);
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("uuuu-MM-dd'T'HH:mm:ssX");
        if (lastUpdated != null) {
            ZonedDateTime last = ZonedDateTime.parse(lastUpdated.getValue(), dtf);
            if (ChronoUnit.HOURS.between(last, ZonedDateTime.now()) < 23) {
                LOG.info("skipping update of KEV as the data feed is only updated once per day.");
                return;
            }
        } else {
            lastUpdated = new Property();
            lastUpdated.setKey(KEV_LAST_UPDATED);
        }
        database.truncateKEV();
        KevDataFeed df;
        if (configuration.containsKey(Configuration.KEY.KEV_URL)) {
            df = new KevDataFeed(configuration.get(Configuration.KEY.KEV_URL));
        } else {
            df = new KevDataFeed();
        }
        KevCatalog catalog = df.download();
        for (KevItem item : catalog.getVulnerabilities()) {
            KevEntry entry = new KevEntry(item);
            database.store(entry);
        }

        lastUpdated.setValue(ZonedDateTime.now(ZoneId.of("UTC")).format(dtf));
        database.store(lastUpdated);
        database.commit();
    }

    private void loadEPSS(VulnerabilityDatabase database) {
        Property lastUpdated = database.getProperty(EPSS_LAST_UPDATED);
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("uuuu-MM-dd'T'HH:mm:ssX");
        if (lastUpdated != null) {
            ZonedDateTime last = ZonedDateTime.parse(lastUpdated.getValue(), dtf);
            if (ChronoUnit.HOURS.between(last, ZonedDateTime.now()) < 23) {
                LOG.info("skipping update of EPSS as the data feed is only updated once per day.");
                return;
            }
        } else {
            lastUpdated = new Property();
            lastUpdated.setKey(EPSS_LAST_UPDATED);
        }
        database.truncateEPSS();
        EpssDataFeed df;
        if (configuration.containsKey(Configuration.KEY.EPSS_URL)) {
            df = new EpssDataFeed(configuration.get(Configuration.KEY.EPSS_URL));
        } else {
            df = new EpssDataFeed();
        }
        for (EpssItem item : df.download()) {
            EpssScore score = new EpssScore(item);
            database.store(score);
        }

        lastUpdated.setValue(ZonedDateTime.now(ZoneId.of("UTC")).format(dtf));
        database.store(lastUpdated);
        database.commit();
    }

    /**
     * Retrieves the CVE Data from the NVD API and persists it to the database. If there is an existing GHSA the CPE
     * from the NVD will be added as affected entries to the existing GHSA.
     *
     * @param database
     * @throws Exception
     */
    private void loadNVD(VulnerabilityDatabase database) throws Exception {
        String apiKey = configuration.get(NVD_API_KEY);
        NvdCveClientBuilder builder = NvdCveClientBuilder.aNvdCveApi();
        if (apiKey != null) {
            if (apiKey.startsWith("op:")) {
                throw new NvdApiException("Invalid NVD API token - received a 1password token");
            } else {
                builder.withApiKey(apiKey);
            }
        }
        if (configuration.containsKey(NVD_ENDPOINT)) {
            builder.withEndpoint(configuration.get(NVD_ENDPOINT));
        }

        Property lastUpdated = database.getProperty(NVD_LAST_UPDATED);
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("uuuu-MM-dd'T'HH:mm:ssX");
        if (lastUpdated != null) {
            ZonedDateTime start = ZonedDateTime.parse(lastUpdated.getValue(), dtf);
            ZonedDateTime end = start.minusDays(-120);
            builder.withLastModifiedFilter(start, end);
        } else {
            lastUpdated = new Property();
            lastUpdated.setKey(NVD_LAST_UPDATED);
        }

        String filter = configuration.get(NVD_CPE_FILTER);
        Cpe cpeFilter = null;
        if (filter != null) {
            builder.withVirtualMatchString(filter);
            cpeFilter = CpeParser.parse(filter, true);
        }
        // int count = 0;
        try (NvdCveClient api = builder.build(); RecordDataSource<DefCveItem> client = new RecordDataSource<>(api)) {
            while (client.hasNext()) {
                try {
                    DefCveItem entry = client.next();
                    if (entry != null) {
                        List<Vulnerability> existingVulnerabilities = database.getVulnerability(entry.getCve().getId());
                        boolean addEntry = true;
                        boolean addCpe = false;
                        if (existingVulnerabilities != null && !existingVulnerabilities.isEmpty()) {
                            // matches
                            for (Vulnerability v : existingVulnerabilities) {
                                // if the vulnerability is only from the NVD delete it
                                if (v.getIdentifiers().size() == 1) {
                                    database.delete(v);
                                } else {
                                    // already covered by GH Security Advisories
                                    addEntry = false;
                                    addCpe = true;
                                }
                            }
                        }
                        if (addEntry || addCpe) {
                            Vulnerability newVuln = VulnerabilityTransformer.from(entry, cpeFilter);
                            if (newVuln != null) {
                                if (addEntry) {
                                    database.store(newVuln);
                                } else if (newVuln.getAffected() != null && !newVuln.getAffected().isEmpty()
                                        && existingVulnerabilities != null && !existingVulnerabilities.isEmpty()) {
                                    // TODO we could try and pair the GHSA purl with the NVD CPE?
                                    for (Vulnerability v : existingVulnerabilities) {
                                        for (Affected a : newVuln.getAffected()) {
                                            v.addAffected(a);
                                        }
                                        database.store(v);
                                    }
                                }
                            }
                        }
                        // count += 1;
                        // LOG.info("Processing {}/{}", count, api.getTotalAvailable());
                    }
                } catch (NvdApiException ex) {
                    LOG.debug("Error retrieving the NVD data", ex);
                    LOG.warn("An error occurred calling the NVD API - retrying request");
                }
            }

            if (client.getLastUpdated() != null) {
                lastUpdated.setValue(client.getLastUpdated().format(dtf));
                database.store(lastUpdated);
            }
            database.commit();
        }
    }

    private void loadGHSA(VulnerabilityDatabase database) throws Exception {
        String apiKey = configuration.get(GHSA_TOKEN);
        if (apiKey == null || apiKey.isBlank() || apiKey.startsWith("op:")) {
            throw new Exception("Invalid github API token - please set a valid environment variable GITHUB_TOKEM");
        }
        GitHubSecurityAdvisoryClientBuilder builder = GitHubSecurityAdvisoryClientBuilder
                .aGitHubSecurityAdvisoryClient().withApiKey(apiKey);

        if (configuration.containsKey(GHSA_ENDPOINT)) {
            builder.withEndpoint(configuration.get(GHSA_ENDPOINT));
        }

        Property lastUpdated = database.getProperty(GHSA_LAST_UPDATED);
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("uuuu-MM-dd'T'HH:mm:ssX");
        if (lastUpdated != null) {
            ZonedDateTime date = ZonedDateTime.parse(lastUpdated.getValue(), dtf);
            builder.withUpdatedSinceFilter(date);
        } else {
            lastUpdated = new Property();
            lastUpdated.setKey(GHSA_LAST_UPDATED);
        }

        try (GitHubSecurityAdvisoryClient api = builder.build();
                RecordDataSource<SecurityAdvisory> client = new RecordDataSource<>(api)) {
            // int count = 0;
            while (client.hasNext()) {
                SecurityAdvisory entry = client.next();
                if (entry != null) {
                    // TODO - also search for CVEs on the advisory (or other datasources once added) - if we have one
                    // from GHSA we trust it more
                    List<Vulnerability> existingVulnerabilities = database.getVulnerability(entry.getGhsaId());
                    // updating is hard... as removing a single version or affected entry in a list of entries is
                    // difficult once data is coming from multiple data sources. We treat GHSA as the most
                    // accurate.
                    if (existingVulnerabilities != null && !existingVulnerabilities.isEmpty()) {
                        for (Vulnerability v : existingVulnerabilities) {
                            database.delete(v);
                        }
                    }
                    Vulnerability newVuln = VulnerabilityTransformer.from(entry);
                    // transfer any affected with CPE entries from the existing vulns to the new vuln
                    if (existingVulnerabilities != null && !existingVulnerabilities.isEmpty()) {
                        for (Vulnerability v : existingVulnerabilities) {
                            if (v.getAffected() != null && !v.getAffected().isEmpty()) {
                                for (Affected a : v.getAffected()) {
                                    if (a.getCpe() != null && !a.getCpe().isBlank()) {
                                        newVuln.addAffected(a);
                                    }
                                }
                            }
                        }
                    }
                    database.store(newVuln);
                    // count += 1;
                    // LOG.info("Processing {}/{}", count, api.getTotalAvailable());
                }
            }
            if (client.getLastUpdated() != null) {
                lastUpdated.setValue(client.getLastUpdated().format(dtf));
                database.store(lastUpdated);
            }
        }
        database.commit();
    }

}
