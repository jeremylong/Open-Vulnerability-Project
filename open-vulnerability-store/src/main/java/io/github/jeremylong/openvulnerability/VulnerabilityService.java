/*
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *
 * SPDX-License-Identifier: Apache-2.0
 * Copyright (c) 2023 Jeremy Long. All Rights Reserved.
 */
package io.github.jeremylong.openvulnerability;

import io.github.jeremylong.openvulnerability.client.RecordDataSource;
import io.github.jeremylong.openvulnerability.client.ghsa.GitHubSecurityAdvisoryClient;
import io.github.jeremylong.openvulnerability.client.ghsa.GitHubSecurityAdvisoryClientBuilder;
import io.github.jeremylong.openvulnerability.client.ghsa.SecurityAdvisory;
import io.github.jeremylong.openvulnerability.client.nvd.DefCveItem;
import io.github.jeremylong.openvulnerability.client.nvd.NvdApiException;
import io.github.jeremylong.openvulnerability.client.nvd.NvdCveClient;
import io.github.jeremylong.openvulnerability.client.nvd.NvdCveClientBuilder;
import io.github.jeremylong.openvulnerability.model.Affected;
import io.github.jeremylong.openvulnerability.model.Property;
import io.github.jeremylong.openvulnerability.model.Vulnerability;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.util.List;

public class VulnerabilityService {

    public static final String NVD_LAST_UPDATED = "nvd_last_updated";
    public static final String GHSA_LAST_UPDATED = "ghsa_last_updated";

    private static final Logger LOG = LoggerFactory.getLogger(VulnerabilityService.class);

    public void updateDatabase(String ghsaToken) {
        updateDatabase(ghsaToken, null);
    }

    public void updateDatabase(String ghsaToken, String nvdApiToken) {
        try (VulnerabilityDatabase database = new VulnerabilityDatabase()) {
            LOG.info("Begin Update");
            LOG.info("Starting GHSA");
            loadGHSA(ghsaToken, database);
            LOG.info("Starting NVD");
            loadNVD(nvdApiToken, database);
            LOG.info("Ending Update");
        } catch (Exception e) {
            LOG.error("Update Failed", e);
        }
    }

    /**
     * Retrieves the CVE Data from the NVD API and persists it to the database. If there is an existing GHSA the CPE
     * from the NVD will be added as affected entries to the existing GHSA.
     *
     * @param apiKey the NVD API key, can be null
     * @param database
     * @throws Exception
     */
    private void loadNVD(String apiKey, VulnerabilityDatabase database) throws Exception {
        NvdCveClientBuilder builder = NvdCveClientBuilder.aNvdCveApi();
        if (apiKey != null) {
            if (apiKey.startsWith("op:")) {
                throw new Exception("Invalid NVD API token - received a 1password token");
            } else {
                builder.withApiKey(apiKey);
            }
        }

        Property lastUpdated = database.getProperty(NVD_LAST_UPDATED);
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("uuuu-MM-dd'T'HH:mm:ssX");
        if (lastUpdated != null) {
            ZonedDateTime start = ZonedDateTime.parse(lastUpdated.getValue(), dtf);
            ZonedDateTime end = start.minusDays(-120);
            builder.withLastModifiedFilter(start, end);
        } else {
            lastUpdated = new Property();
            lastUpdated.setKey(NVD_LAST_UPDATED);
        }

        //builder.withFilter(NvdCveClientBuilder.Filter.CPE_NAME, "cpe:2.3:a:*:*:*:*:*:*:*:*:*:*");

        try (NvdCveClient api = builder.build(); RecordDataSource<DefCveItem> client = new RecordDataSource<>(api)) {
            while (client.hasNext()) {
                try {
                    DefCveItem entry = client.next();
                    if (entry != null) {
                        List<Vulnerability> existingVulnerabilities = database.getVulnerability(entry.getCve().getId());
                        boolean addEntry = true;
                        boolean addCpe = false;
                        if (existingVulnerabilities != null && !existingVulnerabilities.isEmpty()) {
                            // matches
                            for (Vulnerability v : existingVulnerabilities) {
                                // if the vulnerability is only from the NVD delete it
                                if (v.getIdentifiers().size() == 1) {
                                    database.delete(v);
                                } else {
                                    // already covered by GH Security Advisories
                                    addEntry = false;
                                    addCpe = true;
                                }
                            }
                        }
                        if (addEntry || addCpe) {
                            Vulnerability newVuln = VulnerabilityTransformer.from(entry);
                            if (newVuln != null) {
                                if (addEntry) {
                                    database.store(newVuln);
                                } else if (newVuln.getAffected() != null && !newVuln.getAffected().isEmpty()
                                        && existingVulnerabilities != null && !existingVulnerabilities.isEmpty()) {
                                    // TODO we could try and pair the GHSA purl with the NVD CPE?
                                    for (Vulnerability v : existingVulnerabilities) {
                                        for (Affected a : newVuln.getAffected()) {
                                            v.addAffected(a);
                                        }
                                        database.store(v);
                                    }
                                }
                            }
                        }
                    }
                } catch (NvdApiException ex) {
                    LOG.error("Error retrieving the NVD data", ex);
                }
            }
            database.commit();
            if (client.getLastUpdated() != null) {
                lastUpdated.setValue(client.getLastUpdated().format(dtf));
                database.store(lastUpdated);
                database.commit();
            }
        }
    }

    private void loadGHSA(String apiKey, VulnerabilityDatabase database) throws Exception {
        if (apiKey == null || apiKey.isBlank() || apiKey.startsWith("op:")) {
            throw new Exception("Invalid github API token - please set a valid environment variable GITHUB_TOKEM");
        }
        GitHubSecurityAdvisoryClientBuilder builder = GitHubSecurityAdvisoryClientBuilder
                .aGitHubSecurityAdvisoryClient().withApiKey(apiKey);

        Property lastUpdated = database.getProperty(GHSA_LAST_UPDATED);
        DateTimeFormatter dtf = DateTimeFormatter.ofPattern("uuuu-MM-dd'T'HH:mm:ssX");
        if (lastUpdated != null) {
            ZonedDateTime date = ZonedDateTime.parse(lastUpdated.getValue(), dtf);
            builder.withUpdatedSinceFilter(date);
        } else {
            lastUpdated = new Property();
            lastUpdated.setKey(GHSA_LAST_UPDATED);
        }

        try (GitHubSecurityAdvisoryClient api = builder.build();
                RecordDataSource<SecurityAdvisory> client = new RecordDataSource<>(api)) {

            while (client.hasNext()) {
                SecurityAdvisory entry = client.next();
                if (entry != null) {
                    // TODO - also search for CVEs on the advisory (or other datasources once added) - if we have one
                    // from GHSA we trust it more
                    List<Vulnerability> existingVulnerabilities = database.getVulnerability(entry.getGhsaId());
                    // updating is hard... as removing a single version or affected entry in a list of entries is
                    // difficult once data is coming from multiple data sources. We treat GHSA as the most
                    // accurate.
                    if (existingVulnerabilities != null && !existingVulnerabilities.isEmpty()) {
                        for (Vulnerability v : existingVulnerabilities) {
                            database.delete(v);
                        }
                    }
                    Vulnerability newVuln = VulnerabilityTransformer.from(entry);
                    // transfer any affected with CPE entries from the existing vulns to the new vuln
                    if (existingVulnerabilities != null && !existingVulnerabilities.isEmpty()) {
                        for (Vulnerability v : existingVulnerabilities) {
                            if (v.getAffected() != null && !v.getAffected().isEmpty()) {
                                for (Affected a : v.getAffected()) {
                                    if (a.getCpe() != null && !a.getCpe().isBlank()) {
                                        newVuln.addAffected(a);
                                    }
                                }
                            }
                        }
                    }
                    database.store(newVuln);
                }
            }
            if (client.getLastUpdated() != null) {
                lastUpdated.setValue(client.getLastUpdated().format(dtf));
                database.store(lastUpdated);
            }
        }
        database.commit();
    }

}
